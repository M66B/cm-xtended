diff --git a/res/values/strings.xml b/res/values/strings.xml
index 5931dae..12b194b 100644
--- a/res/values/strings.xml
+++ b/res/values/strings.xml
@@ -2387,6 +2389,10 @@
  from unknown sources. You agree that you are solely responsible for any
  damage to your phone or loss of data that may result from using
  these apps.</string>
+
+    <string name="boot_pincode_title">Pincode at boot</string>
+    <string name="boot_pincode_summary">Enter exactly four digits</string>
+
     <!-- Applications settings screen, setting check box title. If checked, applications show more settings options. -->
     <string name="advanced_settings">Advanced settings</string>
     <!-- Applications settings screen, setting check box summary.  This is the summary for "Advanced settings" checkbox  -->
@@ -4674,6 +4680,12 @@
     <string name="performance_settings_warning">These settings are included for experimentation and any changes made to them have the potential to cause instability, crashes, data loss or hardware failures.\n\nWe request you do not file bug reports if any of these settings have been changed from the defaults.</string>
 
     <!-- Performance Settings : Processor Settings -->
+    <!-- Performance Settings : Categories -->
+    <string name="cpu_cat_current_title">Current</string>
+    <string name="cpu_cat_general_title">General</string>
+    <string name="cpu_cat_smartass_title">Smartass</string>
+    <string name="cpu_cat_voltage_title">Voltage</string>
+
     <!-- Performance Settings : Processor settings title -->
     <string name="processor_title">Processor</string>
     <!-- Performance Settings : Processor settings summary. -->
@@ -4688,7 +4700,35 @@
     <string name="cpu_max_freq_title">Maximum CPU frequency</string>
     <string name="cpu_max_freq_summary">%s</string>
     <string name="cpu_set_on_boot">Set on boot</string>
-    <string name="cpu_set_on_boot_summary">Restore the processor settings on boot</string>
+    <string name="cpu_set_on_boot_summary">Restore the general, smartass, and voltage processor settings on boot</string>
+    <string name="cpu_set_on_boot_disabled">Set on boot disabled</string>
+
+    <!-- Performance Settings : Smartass -->
+    <string name="smartass_awake_ideal_freq_title">Awake ideal frequency (awake_ideal_freq)</string>
+    <string name="smartass_awake_ideal_freq_summary">%s\nThe frequency until which CPU is scaled up rapidly on screen-awake (from sleep). Thereafter, scaling up is less aggressive.</string>
+    <string name="smartass_sleep_ideal_freq_title">Sleep ideal frequency (sleep_ideal_freq)</string>
+    <string name="smartass_sleep_ideal_freq_summary">%s\nThe frequency until which CPU is scaled down rapidly when screen is turned off. Thereafter, scaling down is less aggressive.</string>
+    <string name="smartass_sleep_wakeup_freq_title">Sleep wakeup frequency (sleep_wakeup_freq)</string>
+    <string name="smartass_sleep_wakeup_freq_summary">%s\nThe frequency to set when waking up from sleep. When sleep_ideal_freq=0 this will have no effect.</string>
+    <string name="smartass_max_cpu_load_title">Maximum CPU load (max_cpu_load)</string>
+    <string name="smartass_max_cpu_load_summary">%s\nMeasured in percentage 1-100, When CPU load reaches this point, governor will scale CPU up. Higher value means less responsiveness and lower values corresponds to more responsiveness at the cost of battery.</string>
+    <string name="smartass_min_cpu_load_title">Minimum CPU load (min_cpu_load)</string>
+    <string name="smartass_min_cpu_load_summary">%s\nMeasured in percentage 1-100, When CPU load reaches this point, governor will scale CPU down.</string>
+    <string name="smartass_ramp_up_step_title">Ramp up step (ramp_up_step)</string>
+    <string name="smartass_ramp_up_step_summary">%s\nFrequency when ramping up above the ideal frequency. Zero disables and causes to always jump straight to max frequency. When below the ideal frequency we always ramp up to the ideal freq.</string>
+    <string name="smartass_ramp_down_step_title">Ramp down step (ramp_down_step)</string>
+    <string name="smartass_ramp_down_step_summary">%s\nFrequency delta when ramping down below the ideal frequency. Zero disables and will calculate ramp down according to load heuristic. When above the ideal frequency we always ramp down to the ideal freq.</string>
+    <string name="smartass_up_rate_us_title">Up rate (up_rate_us)</string>
+    <string name="smartass_up_rate_us_summary">%s\nThe minimum amount of time to spend at a frequency before we can ramp up. (Ignored below awake-ideal frequency since governor needs to rapidly scale up to awake_ideal_freq when below it)</string>
+    <string name="smartass_down_rate_us_title">Down rate (down_rate_us)</string>
+    <string name="smartass_down_rate_us_summary">%s\nThe minimum amount of time to spend at a frequency before we can ramp down. (Ignored above sleep-ideal frequency since governor needs to rapidly scale down to sleep_ideal_freq when above it)</string>
+    <string name="smartass_boost_enabled_title">Boost enabled (boost_enabled)</string>
+    <string name="smartass_boost_enabled_summary">Android power manager boost pulse support</string>
+    <string name="smartass_boost_pulse_title">Boost pulse (boost_pulse)</string>
+    <string name="smartass_boost_pulse_summary">%s\nCurrent boost pulse duration</string>
+
+    <!-- Performance Settings : Voltage -->
+    <string name="voltage_warning">(use with care)</string>
 
     <!-- Performance Settings : I/O scheduler settings title -->
     <string name="io_scheds_title">I/O scheduler</string>
@@ -4698,6 +4738,8 @@
     <!-- Performance Settings : I/O scheduler settings sub items -->
     <string name="io_sched_title">I/O scheduler</string>
     <string name="io_sched_summary">%S</string>
+    <string name="fsync_title">fsync</string>
+    <string name="fsync_summary">Synchronize a file\'s in-core state with storage device.\nDo not disable unless you know what you are doing!</string>
     <string name="io_sched_set_on_boot">Set on boot</string>
     <string name="io_sched_set_on_boot_summary">Restore the I/O scheduler settings on boot</string>
 
@@ -4713,6 +4755,26 @@
     <!-- Purgeable Assets -->
     <string name="pref_purgeable_assets_title">Allow purging of assets</string>
     <string name="pref_purgeable_assets_summary">Purging of bitmap memory assets allows the freeing of more RAM when needed (requires reboot)</string>
+    <!-- Autogroup -->
+    <string name="pref_autogroup_title">Autogroup</string>
+    <string name="pref_autogroup_summary">Automated per tty (app) task groups. Always restored on boot.</string>
+
+    <!-- Lowmemkiller -->
+    <string name="lowmem_foreground_app_title">Foreground app</string>
+    <string name="lowmem_foreground_app_summary">%s\nThis is the process running the current foreground app. We\'d really rather not kill it!</string>
+    <string name="lowmem_visible_app_title">Visible app</string>
+    <string name="lowmem_visible_app_summary">%s\nThis is a process only hosting activities that are visible to the user, so we\'d prefer they don\'t disappear.</string>
+    <string name="lowmem_secondary_server_title">Secondary server</string>
+    <string name="lowmem_secondary_server_summary">%s\nThis is a process holding a secondary server -- killing it will not have much of an impact as far as the user is concerned.</string>
+    <string name="lowmem_hidden_app_title">Hidden app</string>
+    <string name="lowmem_hidden_app_summary">%s\nThis is a process only hosting activities that are not visible, so it can be killed without any disruption.</string>
+    <string name="lowmem_content_provider_title">Content provider</string>
+    <string name="lowmem_content_provider_summary">%s\nThis is a process with a content provider that does not have any clients attached to it. If it did have any clients, its adjustment would be the one for the highest-priority of those processes.</string>
+    <string name="lowmem_empty_app_title">Empty app</string>
+    <string name="lowmem_empty_app_summary">%s\nThis is a process without anything currently running in it. Definitely the first to go!</string>
+    <string name="lowmem_set_on_boot">Set on boot</string>
+    <string name="lowmem_set_on_boot_summary">Restore the low memory settings on boot</string>
+    <string name="lowmem_set_on_boot_disabled">Set on boot disabled</string>
 
     <!-- Performance Settings : Dithering -->
     <string name="pref_use_dithering_title">Surface improvement</string>
diff --git a/res/xml/ioscheduler_settings.xml b/res/xml/ioscheduler_settings.xml
index e8eb267..b9e4dd3 100644
--- a/res/xml/ioscheduler_settings.xml
+++ b/res/xml/ioscheduler_settings.xml
@@ -25,6 +25,11 @@
         android:title="@string/io_sched_title" />
 
     <CheckBoxPreference
+        android:key="pref_fsync"
+        android:title="@string/fsync_title"
+        android:summary="@string/fsync_summary"/>
+
+    <CheckBoxPreference
         android:key="pref_io_sched_set_on_boot"
         android:title="@string/io_sched_set_on_boot"
         android:summary="@string/io_sched_set_on_boot_summary"/>
diff --git a/res/xml/memory_management.xml b/res/xml/memory_management.xml
index 187c815..1e14775 100644
--- a/res/xml/memory_management.xml
+++ b/res/xml/memory_management.xml
@@ -37,4 +37,46 @@
         android:title="@string/pref_ksm_title"
         android:summary="@string/pref_ksm_summary" />
 
+    <CheckBoxPreference
+        android:key="pref_autogroup"
+        android:title="@string/pref_autogroup_title"
+        android:summary="@string/pref_autogroup_summary" />
+
+    <PreferenceCategory android:title="Low memory killer">
+        <EditTextPreference
+            android:key="pref_lowmem_foreground_app"
+            android:dialogTitle="@string/lowmem_foreground_app_title"
+            android:title="@string/lowmem_foreground_app_title" />
+
+        <EditTextPreference
+            android:key="pref_lowmem_visible_app"
+            android:dialogTitle="@string/lowmem_visible_app_title"
+            android:title="@string/lowmem_visible_app_title" />
+
+        <EditTextPreference
+            android:key="pref_lowmem_secondary_server_app"
+            android:dialogTitle="@string/lowmem_secondary_server_title"
+            android:title="@string/lowmem_secondary_server_title" />
+
+        <EditTextPreference
+            android:key="pref_lowmem_hidden_app"
+            android:dialogTitle="@string/lowmem_hidden_app_title"
+            android:title="@string/lowmem_hidden_app_title" />
+
+        <EditTextPreference
+            android:key="pref_lowmem_content_provider"
+            android:dialogTitle="@string/lowmem_content_provider_title"
+            android:title="@string/lowmem_content_provider_title" />
+
+        <EditTextPreference
+            android:key="pref_lowmem_empty_app"
+            android:dialogTitle="@string/lowmem_empty_app_title"
+            android:title="@string/lowmem_empty_app_title" />
+
+        <CheckBoxPreference
+            android:key="pref_lowmem_set_on_boot"
+            android:title="@string/lowmem_set_on_boot"
+            android:summary="@string/lowmem_set_on_boot_summary"/>
+    </PreferenceCategory>
+
 </PreferenceScreen>
diff --git a/res/xml/processor_settings.xml b/res/xml/processor_settings.xml
index 7d0b0ee..ad267c7 100644
--- a/res/xml/processor_settings.xml
+++ b/res/xml/processor_settings.xml
@@ -19,30 +19,97 @@
     android:title="@string/processor_title"
     xmlns:settings="http://schemas.android.com/apk/res/com.android.settings">
 
-    <Preference
-        android:key="pref_cpu_freq_cur"
-        style="?android:preferenceInformationStyle"
-        android:title="@string/cpu_cur_freq_title"
-        android:selectable="false" />
-
-    <ListPreference
-        android:key="pref_cpu_gov"
-        android:dialogTitle="@string/cpu_governors_title"
-        android:title="@string/cpu_governors_title" />
-
-    <ListPreference
-        android:key="pref_cpu_freq_min"
-        android:dialogTitle="@string/cpu_min_freq_title"
-        android:title="@string/cpu_min_freq_title" />
-
-    <ListPreference
-        android:key="pref_cpu_freq_max"
-        android:dialogTitle="@string/cpu_max_freq_title"
-        android:title="@string/cpu_max_freq_title" />
-
-    <CheckBoxPreference
-        android:key="pref_cpu_set_on_boot"
-        android:title="@string/cpu_set_on_boot"
-        android:summary="@string/cpu_set_on_boot_summary"/>
+    <PreferenceCategory android:title="@string/cpu_cat_current_title">
+        <Preference
+            android:key="pref_cpu_freq_cur"
+            style="?android:preferenceInformationStyle"
+            android:title="@string/cpu_cur_freq_title"
+            android:selectable="false" />
+
+        <Preference
+            android:key="pref_smartass_boost_pulse"
+            style="?android:preferenceInformationStyle"
+            android:title="@string/smartass_boost_pulse_title"
+            android:summary="@string/smartass_boost_pulse_summary"
+            android:selectable="false" />
+    </PreferenceCategory>
+
+    <PreferenceCategory android:title="@string/cpu_cat_general_title">
+        <ListPreference
+            android:key="pref_cpu_gov"
+            android:dialogTitle="@string/cpu_governors_title"
+            android:title="@string/cpu_governors_title" />
+
+        <ListPreference
+            android:key="pref_cpu_freq_min"
+            android:dialogTitle="@string/cpu_min_freq_title"
+            android:title="@string/cpu_min_freq_title" />
+
+        <ListPreference
+            android:key="pref_cpu_freq_max"
+            android:dialogTitle="@string/cpu_max_freq_title"
+            android:title="@string/cpu_max_freq_title" />
+
+        <CheckBoxPreference
+            android:key="pref_cpu_set_on_boot"
+            android:title="@string/cpu_set_on_boot"
+            android:summary="@string/cpu_set_on_boot_summary"/>
+    </PreferenceCategory>
+
+    <PreferenceCategory android:title="@string/cpu_cat_smartass_title">
+        <ListPreference
+            android:key="pref_smartass_awake_ideal_freq"
+            android:dialogTitle="@string/smartass_awake_ideal_freq_title"
+            android:title="@string/smartass_awake_ideal_freq_title" />
+
+        <ListPreference
+            android:key="pref_smartass_sleep_ideal_freq"
+            android:dialogTitle="@string/smartass_sleep_ideal_freq_title"
+            android:title="@string/smartass_sleep_ideal_freq_title" />
+
+        <ListPreference
+            android:key="pref_smartass_sleep_wakeup_freq"
+            android:dialogTitle="@string/smartass_sleep_wakeup_freq_title"
+            android:title="@string/smartass_sleep_wakeup_freq_title" />
+
+        <EditTextPreference
+            android:key="pref_smartass_max_cpu_load"
+            android:dialogTitle="@string/smartass_max_cpu_load_title"
+            android:title="@string/smartass_max_cpu_load_title" />
+
+        <EditTextPreference
+            android:key="pref_smartass_min_cpu_load"
+            android:dialogTitle="@string/smartass_min_cpu_load_title"
+            android:title="@string/smartass_min_cpu_load_title" />
+
+        <EditTextPreference
+            android:key="pref_smartass_ramp_up_step"
+            android:dialogTitle="@string/smartass_ramp_up_step_title"
+            android:title="@string/smartass_ramp_up_step_title" />
+
+        <EditTextPreference
+            android:key="pref_smartass_ramp_down_step"
+            android:dialogTitle="@string/smartass_ramp_down_step_title"
+            android:title="@string/smartass_ramp_down_step_title" />
+
+        <EditTextPreference
+            android:key="pref_smartass_up_rate_us"
+            android:dialogTitle="@string/smartass_up_rate_us_title"
+            android:title="@string/smartass_up_rate_us_title" />
+
+        <EditTextPreference
+            android:key="pref_smartass_down_rate_us"
+            android:dialogTitle="@string/smartass_down_rate_us_title"
+            android:title="@string/smartass_down_rate_us_title" />
+
+        <CheckBoxPreference
+            android:key="pref_smartass_boost_enabled"
+            android:title="@string/smartass_boost_enabled_title"
+            android:summary="@string/smartass_boost_enabled_summary" />
+    </PreferenceCategory>
+
+    <PreferenceCategory
+        android:title="@string/cpu_cat_voltage_title"
+        android:key="pref_vdd_levels" />
 
 </PreferenceScreen>
diff --git a/res/xml/security_settings_misc.xml b/res/xml/security_settings_misc.xml
index 9f78820..2df0a7e 100644
--- a/res/xml/security_settings_misc.xml
+++ b/res/xml/security_settings_misc.xml
@@ -52,6 +52,14 @@
                 android:summaryOn="@string/install_unknown_applications"
                 android:persistent="false" />
 
+        <EditTextPreference
+            android:key="boot_pincode"
+            android:dialogTitle="@string/boot_pincode_title"
+            android:title="@string/boot_pincode_title"
+            android:summary="@string/boot_pincode_summary"
+            android:inputType="number"
+            android:password="true" />
+
     </PreferenceCategory>
 
     <PreferenceCategory android:title="@string/credentials_title"
diff --git a/src/com/android/settings/SecuritySettings.java b/src/com/android/settings/SecuritySettings.java
index 47cbfe0..6df1237 100644
--- a/src/com/android/settings/SecuritySettings.java
+++ b/src/com/android/settings/SecuritySettings.java
@@ -32,6 +32,7 @@ import android.os.UserId;
 import android.os.Vibrator;
 import android.preference.CheckBoxPreference;
 import android.preference.ListPreference;
+import android.preference.EditTextPreference;
 import android.preference.Preference;
 import android.preference.Preference.OnPreferenceChangeListener;
 import android.preference.PreferenceGroup;
@@ -44,6 +45,7 @@ import android.util.Log;
 import com.android.internal.widget.LockPatternUtils;
 
 import java.util.ArrayList;
+import java.io.File;
 
 /**
  * Gesture lock pattern settings.
@@ -72,6 +74,7 @@ public class SecuritySettings extends SettingsPreferenceFragment
     private static final String KEY_SHOW_PASSWORD = "show_password";
     private static final String KEY_RESET_CREDENTIALS = "reset_credentials";
     private static final String KEY_TOGGLE_INSTALL_APPLICATIONS = "toggle_install_applications";
+    public static final String KEY_BOOT_PINCODE = "boot_pincode";
     private static final String KEY_POWER_INSTANTLY_LOCKS = "power_button_instantly_locks";
     private static final String SLIDE_LOCK_DELAY_TOGGLE = "slide_lock_delay_toggle";
     private static final String SLIDE_LOCK_TIMEOUT_DELAY = "slide_lock_timeout_delay";
@@ -83,6 +86,8 @@ public class SecuritySettings extends SettingsPreferenceFragment
     private static final String KEY_SMS_SECURITY_CHECK_PREF = "sms_security_check_limit";
     public static final String KEY_VIBRATE_PREF = "lockscreen_vibrate";
 
+    public static final String BOOT_PINCODE_FILE = "/cache/pin/code";
+
     DevicePolicyManager mDPM;
 
     private ChooseLockSettingsHelper mChooseLockSettingsHelper;
@@ -108,6 +113,7 @@ public class SecuritySettings extends SettingsPreferenceFragment
     private Preference mResetCredentials;
 
     private CheckBoxPreference mToggleAppInstallation;
+    private EditTextPreference mBootPincode;
     private DialogInterface mWarnInstallApps;
     private CheckBoxPreference mPowerButtonInstantlyLocks;
 
@@ -359,6 +365,9 @@ public class SecuritySettings extends SettingsPreferenceFragment
             mToggleAppInstallation = (CheckBoxPreference) findPreference(
                     KEY_TOGGLE_INSTALL_APPLICATIONS);
             mToggleAppInstallation.setChecked(isNonMarketAppsAllowed());
+            mBootPincode = (EditTextPreference) findPreference(
+                    KEY_BOOT_PINCODE);
+            mBootPincode.setOnPreferenceChangeListener(this);
         }
 
         boolean isTelephony = pm.hasSystemFeature(PackageManager.FEATURE_TELEPHONY);
@@ -702,6 +711,14 @@ public class SecuritySettings extends SettingsPreferenceFragment
             Settings.Secure.putInt(getContentResolver(), Settings.Secure.SMS_OUTGOING_CHECK_MAX_COUNT,
                      smsSecurityCheck);
             updateSmsSecuritySummary(smsSecurityCheck);
+        } else if (preference == mBootPincode) {
+            String pincode = (String)value;
+            if (pincode != null && pincode.length() == 4)
+                Utils.fileWriteOneLine(BOOT_PINCODE_FILE, pincode);
+            else {
+                File pfile = new File(SecuritySettings.BOOT_PINCODE_FILE);
+                pfile.delete();
+            }
         }
         return true;
     }
diff --git a/src/com/android/settings/cyanogenmod/BootReceiver.java b/src/com/android/settings/cyanogenmod/BootReceiver.java
index 0704a66..8f71904 100644
--- a/src/com/android/settings/cyanogenmod/BootReceiver.java
+++ b/src/com/android/settings/cyanogenmod/BootReceiver.java
@@ -22,12 +22,20 @@ import android.content.Intent;
 import android.content.SharedPreferences;
 import android.os.SystemProperties;
 import android.preference.PreferenceManager;
+import android.provider.Settings;
+import android.provider.Settings.SettingNotFoundException;
 import android.util.Log;
 
 import com.android.settings.Utils;
+import com.android.settings.SecuritySettings;
+
+import com.google.common.base.Joiner;
 
 import java.util.Arrays;
 import java.util.List;
+import java.io.BufferedReader;
+import java.io.FileReader;
+import java.io.File;
 
 public class BootReceiver extends BroadcastReceiver {
 
@@ -36,6 +44,7 @@ public class BootReceiver extends BroadcastReceiver {
     private static final String CPU_SETTINGS_PROP = "sys.cpufreq.restored";
     private static final String IOSCHED_SETTINGS_PROP = "sys.iosched.restored";
     private static final String KSM_SETTINGS_PROP = "sys.ksm.restored";
+    private static final String MEMORY_SETTINGS_PROP = "sys.memory.restored";
 
     @Override
     public void onReceive(Context ctx, Intent intent) {
@@ -64,45 +73,155 @@ public class BootReceiver extends BroadcastReceiver {
                 SystemProperties.set(KSM_SETTINGS_PROP, "false");
             }
         }
+
+        if (SystemProperties.getBoolean(MEMORY_SETTINGS_PROP, false) == false
+                && intent.getAction().equals(Intent.ACTION_BOOT_COMPLETED)) {
+            SystemProperties.set(MEMORY_SETTINGS_PROP, "true");
+            configureMemory(ctx);
+        } else {
+            SystemProperties.set(MEMORY_SETTINGS_PROP, "false");
+        }
+
+        // Restore pin code
+        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(ctx);
+        String pincode = prefs.getString(SecuritySettings.KEY_BOOT_PINCODE, null);
+        if (pincode != null && pincode.length() == 4)
+            Utils.fileWriteOneLine(SecuritySettings.BOOT_PINCODE_FILE, pincode);
+        else {
+            File pfile = new File(SecuritySettings.BOOT_PINCODE_FILE);
+            pfile.delete();
+        }
     }
 
     private void configureCPU(Context ctx) {
         SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(ctx);
 
         if (prefs.getBoolean(Processor.SOB_PREF, false) == false) {
-            Log.i(TAG, "Restore disabled by user preference.");
+            Log.i(TAG, "CPU: restore disabled by user preference.");
             return;
         }
 
-        String governor = prefs.getString(Processor.GOV_PREF, null);
-        String minFrequency = prefs.getString(Processor.FREQ_MIN_PREF, null);
-        String maxFrequency = prefs.getString(Processor.FREQ_MAX_PREF, null);
-        String availableFrequenciesLine = Utils.fileReadOneLine(Processor.FREQ_LIST_FILE);
-        String availableGovernorsLine = Utils.fileReadOneLine(Processor.GOV_LIST_FILE);
-        boolean noSettings = ((availableGovernorsLine == null) || (governor == null)) &&
-                             ((availableFrequenciesLine == null) || ((minFrequency == null) && (maxFrequency == null)));
-        List<String> frequencies = null;
-        List<String> governors = null;
+        try {
+            String governor = prefs.getString(Processor.GOV_PREF, null);
+            String minFrequency = prefs.getString(Processor.FREQ_MIN_PREF, null);
+            String maxFrequency = prefs.getString(Processor.FREQ_MAX_PREF, null);
+            String availableFrequenciesLine = Utils.fileReadOneLine(Processor.FREQ_LIST_FILE);
+            String availableGovernorsLine = Utils.fileReadOneLine(Processor.GOV_LIST_FILE);
+            boolean noSettings = ((availableGovernorsLine == null) || (governor == null)) &&
+                                 ((availableFrequenciesLine == null) || ((minFrequency == null) && (maxFrequency == null)));
+            List<String> frequencies = null;
+            List<String> governors = null;
 
-        if (noSettings) {
-            Log.d(TAG, "No CPU settings saved. Nothing to restore.");
-        } else {
-            if (availableGovernorsLine != null){
-                governors = Arrays.asList(availableGovernorsLine.split(" "));
-            }
-            if (availableFrequenciesLine != null){
-                frequencies = Arrays.asList(availableFrequenciesLine.split(" "));
-            }
-            if (governor != null && governors != null && governors.contains(governor)) {
-                Utils.fileWriteOneLine(Processor.GOV_FILE, governor);
-            }
-            if (maxFrequency != null && frequencies != null && frequencies.contains(maxFrequency)) {
-                Utils.fileWriteOneLine(Processor.FREQ_MAX_FILE, maxFrequency);
+            if (noSettings) {
+                Log.d(TAG, "No CPU settings saved. Nothing to restore.");
+            } else {
+                if (availableGovernorsLine != null){
+                    governors = Arrays.asList(availableGovernorsLine.split(" "));
+                }
+                if (availableFrequenciesLine != null){
+                    frequencies = Arrays.asList(availableFrequenciesLine.split(" "));
+                }
+                if (governor != null && governors != null && governors.contains(governor)) {
+                    Utils.fileWriteOneLine(Processor.GOV_FILE, governor);
+                }
+                if (maxFrequency != null && frequencies != null && frequencies.contains(maxFrequency)) {
+                    Utils.fileWriteOneLine(Processor.FREQ_MAX_FILE, maxFrequency);
+                }
+                if (minFrequency != null && frequencies != null && frequencies.contains(minFrequency)) {
+                    Utils.fileWriteOneLine(Processor.FREQ_MIN_FILE, minFrequency);
+                }
+                Log.d(TAG, "CPU settings restored.");
             }
-            if (minFrequency != null && frequencies != null && frequencies.contains(minFrequency)) {
-                Utils.fileWriteOneLine(Processor.FREQ_MIN_FILE, minFrequency);
+        }
+        catch (Exception e) {
+            e.printStackTrace();
+        }
+
+        // Smartass
+        try {
+            String file;
+
+            String awake_ideal_freq = prefs.getString(Processor.SMARTASS_AWAKE_IDEAL_FREQ_PREF, null);
+            String sleep_ideal_freq = prefs.getString(Processor.SMARTASS_SLEEP_IDEAL_FREQ_PREF, null);
+            String sleep_wakeup_freq = prefs.getString(Processor.SMARTASS_SLEEP_WAKEUP_FREQ_PREF, null);
+            String max_cpu_load = prefs.getString(Processor.SMARTASS_MAX_CPU_LOAD_PREF, null);
+            String min_cpu_load = prefs.getString(Processor.SMARTASS_MIN_CPU_LOAD_PREF, null);
+            String ramp_up_step = prefs.getString(Processor.SMARTASS_RAMP_UP_STEP_PREF, null);
+            String ramp_down_step = prefs.getString(Processor.SMARTASS_RAMP_DOWN_STEP_PREF, null);
+            String up_rate_us = prefs.getString(Processor.SMARTASS_UP_RATE_US_PREF, null);
+            String down_rate_us = prefs.getString(Processor.SMARTASS_DOWN_RATE_PREF, null);
+            String boost_enabled = (prefs.getBoolean(Processor.SMARTASS_BOOST_ENABLED_PREF, false) ? "1" : "0");
+
+            file = String.format(Processor.SMARTASS_AWAKE_IDEAL_FREQ_FILE, Processor.getSmartass());
+            if (awake_ideal_freq != null && Utils.fileExists(file))
+                Utils.fileWriteOneLine(file, awake_ideal_freq);
+
+            file = String.format(Processor.SMARTASS_SLEEP_IDEAL_FREQ_FILE, Processor.getSmartass());
+            if (sleep_ideal_freq != null && Utils.fileExists(file))
+                Utils.fileWriteOneLine(file, sleep_ideal_freq);
+
+            file = String.format(Processor.SMARTASS_SLEEP_WAKEUP_FREQ_FILE, Processor.getSmartass());
+            if (sleep_wakeup_freq != null && Utils.fileExists(file))
+                Utils.fileWriteOneLine(file, sleep_wakeup_freq);
+
+            file = String.format(Processor.SMARTASS_MAX_CPU_LOAD_FILE, Processor.getSmartass());
+            if (max_cpu_load != null && Utils.fileExists(file))
+                Utils.fileWriteOneLine(file, max_cpu_load);
+
+            file = String.format(Processor.SMARTASS_MIN_CPU_LOAD_FILE, Processor.getSmartass());
+            if (min_cpu_load != null && Utils.fileExists(file))
+                Utils.fileWriteOneLine(file, min_cpu_load);
+
+            file = String.format(Processor.SMARTASS_RAMP_UP_STEP_FILE, Processor.getSmartass());
+            if (ramp_up_step != null && Utils.fileExists(file))
+                Utils.fileWriteOneLine(file, Processor.by1000(ramp_up_step));
+
+            file = String.format(Processor.SMARTASS_RAMP_DOWN_STEP_FILE, Processor.getSmartass());
+            if (ramp_down_step != null && Utils.fileExists(file))
+                Utils.fileWriteOneLine(file, Processor.by1000(ramp_down_step));
+
+            file = String.format(Processor.SMARTASS_UP_RATE_US_FILE, Processor.getSmartass());
+            if (up_rate_us != null && Utils.fileExists(file))
+                Utils.fileWriteOneLine(file, Processor.by1000(up_rate_us));
+
+            file = String.format(Processor.SMARTASS_DOWN_RATE_US_FILE, Processor.getSmartass());
+            if (down_rate_us != null && Utils.fileExists(file))
+                Utils.fileWriteOneLine(file, Processor.by1000(down_rate_us));
+
+            file = String.format(Processor.SMARTASS_BOOST_ENABLED_FILE, Processor.getSmartass());
+            if (boost_enabled != null && Utils.fileExists(file))
+                Utils.fileWriteOneLine(file, boost_enabled);
+
+            Log.d(TAG, "Smartass settings restored.");
+        }
+        catch (Exception e) {
+            e.printStackTrace();
+        }
+
+        // Voltage
+        if (Utils.fileExists(Processor.VDD_LEVELS_FILE)) {
+            BufferedReader vddReader;
+            try {
+                vddReader = new BufferedReader(new FileReader(Processor.VDD_LEVELS_FILE), 512);
+                try {
+                    String line = null;
+                    while ((line = vddReader.readLine()) != null) {
+                        String freq = line.split(":")[0].trim();
+                        String oldMv = line.split(":")[1].trim();
+                        String pref = Processor.VDD_LEVELS_PREF + freq;
+                        String newMv = prefs.getString(pref, null);
+                        if (newMv != null && newMv != oldMv) {
+                            Log.d(TAG, pref + " freq=" + freq + " value=" + newMv + " old=" + oldMv);
+                            Utils.fileWriteOneLine(Processor.VDD_LEVELS_FILE, String.format("%s %s", freq, newMv));
+                        }
+                    }
+                    Log.d(TAG, "Voltage settings restored.");
+                } finally {
+                    vddReader.close();
+                }
+            } catch (Exception e) {
+                e.printStackTrace();
             }
-            Log.d(TAG, "CPU settings restored.");
         }
     }
 
@@ -114,21 +233,40 @@ public class BootReceiver extends BroadcastReceiver {
             return;
         }
 
-        String ioscheduler = prefs.getString(IOScheduler.IOSCHED_PREF, null);
-        String availableIOSchedulersLine = Utils.fileReadOneLine(IOScheduler.IOSCHED_LIST_FILE);
-        boolean noSettings = ((availableIOSchedulersLine == null) || (ioscheduler == null));
-        List<String> ioschedulers = null;
+        // I/O scheduler
+        try {
+            String ioscheduler = prefs.getString(IOScheduler.IOSCHED_PREF, null);
+            String availableIOSchedulersLine = Utils.fileReadOneLine(IOScheduler.IOSCHED_LIST_FILE);
+            boolean noSettings = ((availableIOSchedulersLine == null) || (ioscheduler == null));
+            List<String> ioschedulers = null;
 
-        if (noSettings) {
-            Log.d(TAG, "No I/O scheduler settings saved. Nothing to restore.");
-        } else {
-            if (availableIOSchedulersLine != null){
-                ioschedulers = Arrays.asList(availableIOSchedulersLine.replace("[", "").replace("]", "").split(" "));
+            if (noSettings) {
+                Log.d(TAG, "No I/O scheduler settings saved. Nothing to restore.");
+            } else {
+                if (availableIOSchedulersLine != null){
+                    ioschedulers = Arrays.asList(availableIOSchedulersLine.replace("[", "").replace("]", "").split(" "));
+                }
+                if (ioscheduler != null && ioschedulers != null && ioschedulers.contains(ioscheduler)) {
+                    Utils.fileWriteOneLine(IOScheduler.IOSCHED_LIST_FILE, ioscheduler);
+                }
+                Log.d(TAG, "I/O scheduler settings restored.");
             }
-            if (ioscheduler != null && ioschedulers != null && ioschedulers.contains(ioscheduler)) {
-                Utils.fileWriteOneLine(IOScheduler.IOSCHED_LIST_FILE, ioscheduler);
+        }
+        catch (Exception e) {
+            e.printStackTrace();
+        }
+
+        // fsync
+        try {
+            if (Utils.fileExists(IOScheduler.FSYNC_FILE)) {
+                String fsync = (prefs.getBoolean(IOScheduler.FSYNC_PREF, true) ? "Y" : "N");
+                Log.d(TAG, "fsync=" + fsync);
+                Utils.fileWriteOneLine(IOScheduler.FSYNC_FILE, fsync);
+                Log.d(TAG, "fsync restored.");
             }
-            Log.d(TAG, "I/O scheduler settings restored.");
+        }
+        catch (Exception e) {
+            e.printStackTrace();
         }
     }
 
@@ -140,4 +278,51 @@ public class BootReceiver extends BroadcastReceiver {
         Utils.fileWriteOneLine(MemoryManagement.KSM_RUN_FILE, ksm ? "1" : "0");
         Log.d(TAG, "KSM settings restored.");
     }
+
+    private void configureMemory(Context ctx) {
+        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(ctx);
+
+        // Autogroup
+        try {
+            if (Utils.fileExists(MemoryManagement.AUTOGROUP_FILE)) {
+                String autogroup = (prefs.getBoolean(MemoryManagement.AUTOGROUP_PREF, true) ? "1" : "0");
+                Log.d(TAG, "Autogroup=" + autogroup);
+                Utils.fileWriteOneLine(MemoryManagement.AUTOGROUP_FILE, autogroup);
+                Log.d(TAG, "Autogroup restored.");
+            }
+        }
+        catch (Exception e) {
+            e.printStackTrace();
+        }
+
+        if (prefs.getBoolean(MemoryManagement.LOWMEM_SOB_PREF, false) == false) {
+            Log.i(TAG, "Lowmem: restore disabled by user preference.");
+            return;
+        }
+
+        // Lowmem
+        try {
+            String temp;
+            if (Utils.fileExists(MemoryManagement.LOWMEM_FILE) &&
+                (temp = Utils.fileReadOneLine(MemoryManagement.LOWMEM_FILE)) != null) {
+                String[] lowmem = Utils.fileReadOneLine(MemoryManagement.LOWMEM_FILE).split(",");
+                Log.d(TAG, "lowmem before=" + Joiner.on(",").join(lowmem));
+                if (lowmem.length == 6) {
+                    lowmem[0] = MemoryManagement.toPages(prefs.getString(MemoryManagement.LOWMEM_FOREGROUND_APP_PREF, MemoryManagement.fromPages(lowmem[0])));
+                    lowmem[1] = MemoryManagement.toPages(prefs.getString(MemoryManagement.LOWMEM_VISIBLE_APP_PREF,  MemoryManagement.fromPages(lowmem[1])));
+                    lowmem[2] = MemoryManagement.toPages(prefs.getString(MemoryManagement.LOWMEM_SECONDARY_SERVER_APP_PREF,  MemoryManagement.fromPages(lowmem[2])));
+                    lowmem[3] = MemoryManagement.toPages(prefs.getString(MemoryManagement.LOWMEM_HIDDEN_APP_PREF,  MemoryManagement.fromPages(lowmem[3])));
+                    lowmem[4] = MemoryManagement.toPages(prefs.getString(MemoryManagement.LOWMEM_CONTENT_PROVIDER_PREF,  MemoryManagement.fromPages(lowmem[4])));
+                    lowmem[5] = MemoryManagement.toPages(prefs.getString(MemoryManagement.LOWMEM_EMPTY_APP_PREF,  MemoryManagement.fromPages(lowmem[5])));
+                    temp = Joiner.on(",").join(lowmem);
+                    Log.d(TAG, "lowmem after=" + temp);
+                    Utils.fileWriteOneLine(MemoryManagement.LOWMEM_FILE, temp);
+                    Log.d(TAG, "Low memory killer values restored.");
+                }
+            }
+        }
+        catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
 }
diff --git a/src/com/android/settings/cyanogenmod/IOScheduler.java b/src/com/android/settings/cyanogenmod/IOScheduler.java
index 68142c5..a8d6524 100644
--- a/src/com/android/settings/cyanogenmod/IOScheduler.java
+++ b/src/com/android/settings/cyanogenmod/IOScheduler.java
@@ -19,6 +19,7 @@ package com.android.settings.cyanogenmod;
 import android.os.Bundle;
 import android.os.Handler;
 import android.os.Message;
+import android.preference.CheckBoxPreference;
 import android.preference.ListPreference;
 import android.preference.Preference;
 import android.preference.PreferenceScreen;
@@ -35,6 +36,8 @@ public class IOScheduler extends SettingsPreferenceFragment implements
 
     public static final String IOSCHED_PREF = "pref_io_sched";
     public static final String IOSCHED_LIST_FILE = "/sys/block/mmcblk0/queue/scheduler";
+    public static final String FSYNC_PREF = "pref_fsync";
+    public static final String FSYNC_FILE = "/sys/module/sync/parameters/fsync_enabled";
 
     public static final String SOB_PREF = "pref_io_sched_set_on_boot";
 
@@ -43,6 +46,7 @@ public class IOScheduler extends SettingsPreferenceFragment implements
     private String mIOSchedulerFormat;
 
     private ListPreference mIOSchedulerPref;
+    private CheckBoxPreference mFsyncPref;
 
     @Override
     public void onCreate(Bundle savedInstanceState) {
@@ -60,6 +64,7 @@ public class IOScheduler extends SettingsPreferenceFragment implements
         PreferenceScreen prefScreen = getPreferenceScreen();
 
         mIOSchedulerPref = (ListPreference) prefScreen.findPreference(IOSCHED_PREF);
+        mFsyncPref = (CheckBoxPreference) prefScreen.findPreference(FSYNC_PREF);
 
         /* I/O scheduler
         Some systems might not use I/O schedulers */
@@ -81,6 +86,14 @@ public class IOScheduler extends SettingsPreferenceFragment implements
             mIOSchedulerPref.setSummary(String.format(mIOSchedulerFormat, currentIOScheduler));
             mIOSchedulerPref.setOnPreferenceChangeListener(this);
         }
+
+        String temp;
+        if (!Utils.fileExists(FSYNC_FILE) || (temp = Utils.fileReadOneLine(FSYNC_FILE)) == null) {
+            mFsyncPref.setEnabled(false);
+        } else {
+            mFsyncPref.setChecked(!temp.startsWith("N"));
+            mFsyncPref.setOnPreferenceChangeListener(this);
+        }
     }
 
     @Override
@@ -109,6 +122,10 @@ public class IOScheduler extends SettingsPreferenceFragment implements
             if (preference == mIOSchedulerPref) {
                 fname = IOSCHED_LIST_FILE;
             }
+            else if (preference == mFsyncPref) {
+                fname = FSYNC_FILE;
+                newValue = (newValue.toString().equals("true") ? "Y" : "N");
+            }
 
             if (Utils.fileWriteOneLine(fname, (String) newValue)) {
                 if (preference == mIOSchedulerPref) {
diff --git a/src/com/android/settings/cyanogenmod/MemoryManagement.java b/src/com/android/settings/cyanogenmod/MemoryManagement.java
index 8626b06..8f41b7c 100644
--- a/src/com/android/settings/cyanogenmod/MemoryManagement.java
+++ b/src/com/android/settings/cyanogenmod/MemoryManagement.java
@@ -22,14 +22,20 @@ import android.os.Bundle;
 import android.os.SystemProperties;
 import android.preference.CheckBoxPreference;
 import android.preference.ListPreference;
+import android.preference.EditTextPreference;
 import android.preference.Preference;
 import android.preference.Preference.OnPreferenceChangeListener;
 import android.preference.PreferenceScreen;
+import android.widget.Toast;
+import android.view.Gravity;
+import android.util.Log;
 
 import com.android.settings.R;
 import com.android.settings.SettingsPreferenceFragment;
 import com.android.settings.Utils;
 
+import com.google.common.base.Joiner;
+
 public class MemoryManagement extends SettingsPreferenceFragment implements
         OnPreferenceChangeListener {
 
@@ -53,11 +59,39 @@ public class MemoryManagement extends SettingsPreferenceFragment implements
 
     private static final String PURGEABLE_ASSETS_DEFAULT = "0";
 
+    public static final String AUTOGROUP_FILE = "/proc/sys/kernel/sched_autogroup_enabled";
+    public static final String AUTOGROUP_PREF = "pref_autogroup";
+
+    public static final String LOWMEM_FILE = "/sys/module/lowmemorykiller/parameters/minfree";
+    public static final String LOWMEM_FOREGROUND_APP_PREF = "pref_lowmem_foreground_app";
+    public static final String LOWMEM_VISIBLE_APP_PREF = "pref_lowmem_visible_app";
+    public static final String LOWMEM_SECONDARY_SERVER_APP_PREF = "pref_lowmem_secondary_server_app";
+    public static final String LOWMEM_HIDDEN_APP_PREF = "pref_lowmem_hidden_app";
+    public static final String LOWMEM_CONTENT_PROVIDER_PREF = "pref_lowmem_content_provider";
+    public static final String LOWMEM_EMPTY_APP_PREF = "pref_lowmem_empty_app";
+    public static final String LOWMEM_SOB_PREF = "pref_lowmem_set_on_boot";
+
+    private static final String TAG = "MemoryManagement";
+
     private ListPreference mzRAM;
 
     private CheckBoxPreference mPurgeableAssetsPref;
-
     private CheckBoxPreference mKSMPref;
+    private CheckBoxPreference mAutogroupPref;
+    private EditTextPreference mLowmemForegroundAppPref;
+    private EditTextPreference mLowmemVisibleAppPref;
+    private EditTextPreference mLowmemSecondaryServerPref;
+    private EditTextPreference mLowmemHiddenAppPref;
+    private EditTextPreference mLowmemContentProviderPref;
+    private EditTextPreference mLowmemEmptyAppPref;
+    private CheckBoxPreference mLowmemSOBPref;
+
+    private String mLowmemForegroundAppFormat;
+    private String mLowmemVisibleAppFormat;
+    private String mLowmemSecondaryServerFormat;
+    private String mLowmemHiddenAppFormat;
+    private String mLowmemContentProviderFormat;
+    private String mLowmemEmptyAppFormat;
 
     private int swapAvailable = -1;
 
@@ -66,6 +100,12 @@ public class MemoryManagement extends SettingsPreferenceFragment implements
         super.onCreate(savedInstanceState);
 
         if (getPreferenceManager() != null) {
+            mLowmemForegroundAppFormat = getString(R.string.lowmem_foreground_app_summary);
+            mLowmemVisibleAppFormat = getString(R.string.lowmem_visible_app_summary);
+            mLowmemSecondaryServerFormat = getString(R.string.lowmem_secondary_server_summary);
+            mLowmemHiddenAppFormat = getString(R.string.lowmem_hidden_app_summary);
+            mLowmemContentProviderFormat = getString(R.string.lowmem_content_provider_summary);
+            mLowmemEmptyAppFormat = getString(R.string.lowmem_empty_app_summary);
 
             addPreferencesFromResource(R.xml.memory_management);
 
@@ -74,6 +114,15 @@ public class MemoryManagement extends SettingsPreferenceFragment implements
             mzRAM = (ListPreference) prefSet.findPreference(ZRAM_PREF);
             mPurgeableAssetsPref = (CheckBoxPreference) prefSet.findPreference(PURGEABLE_ASSETS_PREF);
             mKSMPref = (CheckBoxPreference) prefSet.findPreference(KSM_PREF);
+            mAutogroupPref = (CheckBoxPreference) prefSet.findPreference(AUTOGROUP_PREF);
+
+            mLowmemForegroundAppPref = (EditTextPreference) prefSet.findPreference(LOWMEM_FOREGROUND_APP_PREF);
+            mLowmemVisibleAppPref = (EditTextPreference) prefSet.findPreference(LOWMEM_VISIBLE_APP_PREF);
+            mLowmemSecondaryServerPref = (EditTextPreference) prefSet.findPreference(LOWMEM_SECONDARY_SERVER_APP_PREF);
+            mLowmemHiddenAppPref = (EditTextPreference) prefSet.findPreference(LOWMEM_HIDDEN_APP_PREF);
+            mLowmemContentProviderPref = (EditTextPreference) prefSet.findPreference(LOWMEM_CONTENT_PROVIDER_PREF);
+            mLowmemEmptyAppPref = (EditTextPreference) prefSet.findPreference(LOWMEM_EMPTY_APP_PREF);
+            mLowmemSOBPref = (CheckBoxPreference) prefSet.findPreference(LOWMEM_SOB_PREF);
 
             if (isSwapAvailable()) {
                 if (SystemProperties.get(ZRAM_PERSIST_PROP) == "1")
@@ -90,6 +139,56 @@ public class MemoryManagement extends SettingsPreferenceFragment implements
                 prefSet.removePreference(mKSMPref);
             }
 
+            String temp;
+            if (!Utils.fileExists(AUTOGROUP_FILE) || (temp = Utils.fileReadOneLine(AUTOGROUP_FILE)) == null) {
+                mAutogroupPref.setEnabled(false);
+            } else {
+                mAutogroupPref.setChecked(!temp.startsWith("0"));
+                mAutogroupPref.setOnPreferenceChangeListener(this);
+            }
+
+            if (!Utils.fileExists(LOWMEM_FILE) || (temp = Utils.fileReadOneLine(LOWMEM_FILE)) == null) {
+                mLowmemForegroundAppPref.setEnabled(false);
+                mLowmemVisibleAppPref.setEnabled(false);
+                mLowmemSecondaryServerPref.setEnabled(false);
+                mLowmemHiddenAppPref.setEnabled(false);
+                mLowmemContentProviderPref.setEnabled(false);
+                mLowmemEmptyAppPref.setEnabled(false);
+            } else {
+                String[] lowmemValue = temp.split(",");
+                if (lowmemValue.length != 6) {
+                    mLowmemForegroundAppPref.setEnabled(false);
+                    mLowmemVisibleAppPref.setEnabled(false);
+                    mLowmemSecondaryServerPref.setEnabled(false);
+                    mLowmemHiddenAppPref.setEnabled(false);
+                    mLowmemContentProviderPref.setEnabled(false);
+                    mLowmemEmptyAppPref.setEnabled(false);
+                    Log.w(TAG, LOWMEM_FILE + " has " + lowmemValue.length + " entries: " + temp);
+                }
+                else {
+                    mLowmemForegroundAppPref.setText(fromPages(lowmemValue[0]));
+                    mLowmemVisibleAppPref.setText(fromPages(lowmemValue[1]));
+                    mLowmemSecondaryServerPref.setText(fromPages(lowmemValue[2]));
+                    mLowmemHiddenAppPref.setText(fromPages(lowmemValue[3]));
+                    mLowmemContentProviderPref.setText(fromPages(lowmemValue[4]));
+                    mLowmemEmptyAppPref.setText(fromPages(lowmemValue[5]));
+
+                    mLowmemForegroundAppPref.setSummary(String.format(mLowmemForegroundAppFormat, toMB(lowmemValue[0])));
+                    mLowmemVisibleAppPref.setSummary(String.format(mLowmemVisibleAppFormat, toMB(lowmemValue[1])));
+                    mLowmemSecondaryServerPref.setSummary(String.format(mLowmemSecondaryServerFormat, toMB(lowmemValue[2])));
+                    mLowmemHiddenAppPref.setSummary(String.format(mLowmemHiddenAppFormat, toMB(lowmemValue[3])));
+                    mLowmemContentProviderPref.setSummary(String.format(mLowmemContentProviderFormat, toMB(lowmemValue[4])));
+                    mLowmemEmptyAppPref.setSummary(String.format(mLowmemEmptyAppFormat, toMB(lowmemValue[5])));
+
+                    mLowmemForegroundAppPref.setOnPreferenceChangeListener(this);
+                    mLowmemVisibleAppPref.setOnPreferenceChangeListener(this);
+                    mLowmemSecondaryServerPref.setOnPreferenceChangeListener(this);
+                    mLowmemHiddenAppPref.setOnPreferenceChangeListener(this);
+                    mLowmemContentProviderPref.setOnPreferenceChangeListener(this);
+                    mLowmemEmptyAppPref.setOnPreferenceChangeListener(this);
+                }
+            }
+
             String purgeableAssets = SystemProperties.get(PURGEABLE_ASSETS_PERSIST_PROP,
                     PURGEABLE_ASSETS_DEFAULT);
             mPurgeableAssetsPref.setChecked("1".equals(purgeableAssets));
@@ -115,11 +214,61 @@ public class MemoryManagement extends SettingsPreferenceFragment implements
     }
 
     public boolean onPreferenceChange(Preference preference, Object newValue) {
-        if (preference == mzRAM) {
-            if (newValue != null) {
+        if (newValue != null) {
+            // Safety first
+            if (preference.getKey().startsWith("pref_lowmem_") && preference != mLowmemSOBPref) {
+                mLowmemSOBPref.setChecked(false);
+                Toast toast = Toast.makeText(preference.getContext(),
+                    preference.getContext().getString(R.string.lowmem_set_on_boot_disabled),
+                    Toast.LENGTH_SHORT);
+                toast.setGravity(Gravity.CENTER_HORIZONTAL | Gravity.CENTER_VERTICAL, 0, 0);
+                toast.show();
+            }
+
+            if (preference == mzRAM) {
                 SystemProperties.set(ZRAM_PERSIST_PROP, (String) newValue);
                 return true;
             }
+            else if (preference == mAutogroupPref) {
+                newValue = (newValue.toString().equals("true") ? "1" : "0");
+                Log.d(TAG, "Autogroup=" + newValue);
+                return Utils.fileWriteOneLine(AUTOGROUP_FILE, (String) newValue);
+            }
+            else if (preference == mLowmemForegroundAppPref ||
+                preference == mLowmemVisibleAppPref ||
+                preference == mLowmemSecondaryServerPref ||
+                preference == mLowmemHiddenAppPref ||
+                preference == mLowmemContentProviderPref ||
+                preference == mLowmemEmptyAppPref) {
+
+                String[] lowmemValue = Utils.fileReadOneLine(LOWMEM_FILE).split(",");
+                Log.d(TAG, "lowmem before=" + Joiner.on(",").join(lowmemValue));
+                newValue = toPages((String) newValue);
+                if (preference == mLowmemForegroundAppPref)
+                    lowmemValue[0] = (String) newValue;
+                if (preference == mLowmemVisibleAppPref)
+                    lowmemValue[1] = (String) newValue;
+                if (preference == mLowmemSecondaryServerPref)
+                    lowmemValue[2] = (String) newValue;
+                if (preference == mLowmemHiddenAppPref)
+                    lowmemValue[3] = (String) newValue;
+                if (preference == mLowmemContentProviderPref)
+                    lowmemValue[4] = (String) newValue;
+                if (preference == mLowmemEmptyAppPref)
+                    lowmemValue[5] = (String) newValue;
+                String temp = Joiner.on(",").join(lowmemValue);
+                Log.d(TAG, "lowmem after=" + temp);
+
+                if (Utils.fileWriteOneLine(LOWMEM_FILE, temp)) {
+                    mLowmemForegroundAppPref.setSummary(String.format(mLowmemForegroundAppFormat, toMB(lowmemValue[0])));
+                    mLowmemVisibleAppPref.setSummary(String.format(mLowmemVisibleAppFormat, toMB(lowmemValue[1])));
+                    mLowmemSecondaryServerPref.setSummary(String.format(mLowmemSecondaryServerFormat, toMB(lowmemValue[2])));
+                    mLowmemHiddenAppPref.setSummary(String.format(mLowmemHiddenAppFormat, toMB(lowmemValue[3])));
+                    mLowmemContentProviderPref.setSummary(String.format(mLowmemContentProviderFormat, toMB(lowmemValue[4])));
+                    mLowmemEmptyAppPref.setSummary(String.format(mLowmemEmptyAppFormat, toMB(lowmemValue[5])));
+                    return true;
+                }
+            }
         }
 
         return false;
@@ -134,4 +283,27 @@ public class MemoryManagement extends SettingsPreferenceFragment implements
         }
         return swapAvailable > 0;
     }
+
+    private String toMB(String pageString) {
+        return new StringBuilder().append(Integer.valueOf(pageString) * 4 / 1024).append(" MB")
+                .toString();
+    }
+
+    public static String fromPages(String xString) {
+        try {
+            return Integer.toString(Integer.parseInt(xString) * 4 / 1024);
+        }
+        catch (NumberFormatException ex) {
+            return "";
+        }
+    }
+
+    public static String toPages(String xString) {
+        try {
+            return Integer.toString(Integer.parseInt(xString) * 1024 / 4);
+        }
+        catch (NumberFormatException ex) {
+            return "";
+        }
+    }
 }
diff --git a/src/com/android/settings/cyanogenmod/Processor.java b/src/com/android/settings/cyanogenmod/Processor.java
index ce2c404..cba6285 100644
--- a/src/com/android/settings/cyanogenmod/Processor.java
+++ b/src/com/android/settings/cyanogenmod/Processor.java
@@ -22,11 +22,22 @@ import android.os.Message;
 import android.preference.ListPreference;
 import android.preference.Preference;
 import android.preference.PreferenceScreen;
+import android.preference.EditTextPreference;
+import android.preference.CheckBoxPreference;
+import android.preference.PreferenceCategory;
+import android.widget.Toast;
+import android.view.Gravity;
+import android.util.Log;
 
 import com.android.settings.R;
 import com.android.settings.SettingsPreferenceFragment;
 import com.android.settings.Utils;
 
+import java.io.BufferedReader;
+import java.io.FileReader;
+import java.util.Map;
+import java.util.HashMap;
+
 //
 // CPU Related Settings
 //
@@ -47,16 +58,102 @@ public class Processor extends SettingsPreferenceFragment implements
     public static final String FREQ_MIN_FILE = "/sys/devices/system/cpu/cpu0/cpufreq/scaling_min_freq";
     public static final String SOB_PREF = "pref_cpu_set_on_boot";
 
+    public static final String SMARTASS_AWAKE_IDEAL_FREQ_PREF = "pref_smartass_awake_ideal_freq";
+    public static final String SMARTASS_SLEEP_IDEAL_FREQ_PREF = "pref_smartass_sleep_ideal_freq";
+    public static final String SMARTASS_SLEEP_WAKEUP_FREQ_PREF = "pref_smartass_sleep_wakeup_freq";
+    public static final String SMARTASS_MAX_CPU_LOAD_PREF = "pref_smartass_max_cpu_load";
+    public static final String SMARTASS_MIN_CPU_LOAD_PREF = "pref_smartass_min_cpu_load";
+    public static final String SMARTASS_RAMP_UP_STEP_PREF = "pref_smartass_ramp_up_step";
+    public static final String SMARTASS_RAMP_DOWN_STEP_PREF = "pref_smartass_ramp_down_step";
+    public static final String SMARTASS_UP_RATE_US_PREF = "pref_smartass_up_rate_us";
+    public static final String SMARTASS_DOWN_RATE_PREF = "pref_smartass_down_rate_us";
+    public static final String SMARTASS_BOOST_ENABLED_PREF = "pref_smartass_boost_enabled";
+    public static final String SMARTASS_BOOST_PULSE_PREF = "pref_smartass_boost_pulse";
+
+    public static final String SMARTASS_AWAKE_IDEAL_FREQ_FILE = "/sys/devices/system/cpu/cpufreq/%s/awake_ideal_freq";
+    public static final String SMARTASS_SLEEP_IDEAL_FREQ_FILE = "/sys/devices/system/cpu/cpufreq/%s/sleep_ideal_freq";
+    public static final String SMARTASS_SLEEP_WAKEUP_FREQ_FILE = "/sys/devices/system/cpu/cpufreq/%s/sleep_wakeup_freq";
+    public static final String SMARTASS_MAX_CPU_LOAD_FILE = "/sys/devices/system/cpu/cpufreq/%s/max_cpu_load";
+    public static final String SMARTASS_MIN_CPU_LOAD_FILE = "/sys/devices/system/cpu/cpufreq/%s/min_cpu_load";
+    public static final String SMARTASS_RAMP_UP_STEP_FILE = "/sys/devices/system/cpu/cpufreq/%s/ramp_up_step";
+    public static final String SMARTASS_RAMP_DOWN_STEP_FILE = "/sys/devices/system/cpu/cpufreq/%s/ramp_down_step";
+    public static final String SMARTASS_UP_RATE_US_FILE = "/sys/devices/system/cpu/cpufreq/%s/up_rate_us";
+    public static final String SMARTASS_DOWN_RATE_US_FILE = "/sys/devices/system/cpu/cpufreq/%s/down_rate_us";
+    public static final String SMARTASS_BOOST_ENABLED_FILE = "/sys/devices/system/cpu/cpufreq/%s/boost_enabled";
+    public static final String SMARTASS_BOOST_PULSE_FILE = "/sys/devices/system/cpu/cpufreq/%s/boost_pulse";
+
+    private static final String VDD_LEVELS_CAT = "pref_vdd_levels";
+    public static final String VDD_LEVELS_PREF =  "pref_volt_";
+    public static final String VDD_LEVELS_FILE = "/sys/devices/system/cpu/cpu0/cpufreq/vdd_levels";
+    private final static int VDD_MIN = 750;
+    private final static int VDD_MAX = 1500;
+    private final static int VDD_STEP = 25;
+    private final static int VDD_WARN = 1325;
+    private Map<String, String> mvDefault = new HashMap<String, String>() {{
+        put("24576", "900");
+        put("61440", "900");
+        put("122880", "900");
+        put("134400", "900");
+        put("184320", "900");
+        put("192000", "900");
+        put("245760", "900");
+        put("249600", "900");
+        put("364800", "900");
+        put("368640", "900");
+        put("460800", "950");
+        put("576000", "1000");
+        put("652800", "1050");
+        put("768000", "1050");
+        put("806400", "1100");
+        put("921600", "1150");
+        put("1017600", "1200");
+        put("1024000", "1200");
+        put("1113600", "1200");
+        put("1200000", "1200");
+        put("1209600", "1200");
+        put("1305600", "1250");
+        put("1401600", "1250");
+        put("1516800", "1300");
+        put("1612800", "1300");
+    }};
+
     private static final String TAG = "CPUSettings";
 
     private String mGovernorFormat;
     private String mMinFrequencyFormat;
     private String mMaxFrequencyFormat;
 
+    private String mSmartassAwakeIdealFreqFormat;
+    private String mSmartassSleepIdealFreqFormat;
+    private String mSmartassSleepWakeupFreqFormat;
+    private String mSmartassMaxCpuLoadFormat;
+    private String mSmartassMinCpuLoadFormat;
+    private String mSmartassRampUpStepFormat;
+    private String mSmartassRampDownStepFormat;
+    private String mSmartassUpRateUsFormat;
+    private String mSmartassDownRateUsFormat;
+    private String mSmartassBoostPulseFormat;
+
     private Preference mCurFrequencyPref;
     private ListPreference mGovernorPref;
     private ListPreference mMinFrequencyPref;
     private ListPreference mMaxFrequencyPref;
+    private CheckBoxPreference mSOBPref;
+
+    private ListPreference mSmartassAwakeIdealFreqPref;
+    private ListPreference mSmartassSleepIdealFreqPref;
+    private ListPreference mSmartassSleepWakeupFreqPref;
+    private EditTextPreference mSmartassMaxCpuLoadPref;
+    private EditTextPreference mSmartassMinCpuLoadPref;
+    private EditTextPreference mSmartassRampUpStepPref;
+    private EditTextPreference mSmartassRampDownStepPref;
+    private EditTextPreference mSmartassUpRateUsPref;
+    private EditTextPreference mSmartassDownRateUsPref;
+    private CheckBoxPreference mSmartassBoostEnabledPref;
+    private Preference mSmartassBoostPulsePref;
+
+    private static final int what_cur_freq = 1;
+    private static final int what_boost_pulse = 2;
 
     private class CurCPUThread extends Thread {
         private boolean mInterrupt = false;
@@ -70,9 +167,17 @@ public class Processor extends SettingsPreferenceFragment implements
             try {
                 while (!mInterrupt) {
                     sleep(500);
-                    final String curFreq = Utils.fileReadOneLine(FREQ_CUR_FILE);
+
+                    final String curFreq = (Utils.fileExists(FREQ_CUR_FILE)
+                        ? Utils.fileReadOneLine(FREQ_CUR_FILE)
+                        : null);
                     if (curFreq != null)
-                        mCurCPUHandler.sendMessage(mCurCPUHandler.obtainMessage(0, curFreq));
+                        mCurCPUHandler.sendMessage(mCurCPUHandler.obtainMessage(what_cur_freq, curFreq));
+
+                    final String fileBoost = String.format(SMARTASS_BOOST_PULSE_FILE, getSmartass());
+                    final String curBoost = (Utils.fileExists(fileBoost) ? Utils.fileReadOneLine(fileBoost) : null);
+                    if (curBoost != null)
+                        mCurCPUHandler.sendMessage(mCurCPUHandler.obtainMessage(what_boost_pulse, curBoost));
                 }
             } catch (InterruptedException e) {
             }
@@ -83,7 +188,11 @@ public class Processor extends SettingsPreferenceFragment implements
 
     private Handler mCurCPUHandler = new Handler() {
         public void handleMessage(Message msg) {
-            mCurFrequencyPref.setSummary(toMHz((String) msg.obj));
+            if (msg.what == what_cur_freq)
+                mCurFrequencyPref.setSummary(toMHz((String) msg.obj));
+            else if (msg.what == what_boost_pulse)
+                mSmartassBoostPulsePref.setSummary(String.format(mSmartassBoostPulseFormat,
+                    toMs((String) msg.obj)));
         }
     };
 
@@ -95,6 +204,18 @@ public class Processor extends SettingsPreferenceFragment implements
         mMinFrequencyFormat = getString(R.string.cpu_min_freq_summary);
         mMaxFrequencyFormat = getString(R.string.cpu_max_freq_summary);
 
+        // Smartass format strings
+        mSmartassAwakeIdealFreqFormat = getString(R.string.smartass_awake_ideal_freq_summary);
+        mSmartassSleepIdealFreqFormat = getString(R.string.smartass_sleep_ideal_freq_summary);
+        mSmartassSleepWakeupFreqFormat = getString(R.string.smartass_sleep_wakeup_freq_summary);
+        mSmartassMaxCpuLoadFormat = getString(R.string.smartass_max_cpu_load_summary);
+        mSmartassMinCpuLoadFormat = getString(R.string.smartass_min_cpu_load_summary);
+        mSmartassRampUpStepFormat = getString(R.string.smartass_ramp_up_step_summary);
+        mSmartassRampDownStepFormat = getString(R.string.smartass_ramp_down_step_summary);
+        mSmartassUpRateUsFormat = getString(R.string.smartass_up_rate_us_summary);
+        mSmartassDownRateUsFormat = getString(R.string.smartass_down_rate_us_summary);
+        mSmartassBoostPulseFormat = getString(R.string.smartass_boost_pulse_summary);
+
         String[] availableFrequencies = new String[0];
         String[] availableGovernors = new String[0];
         String[] frequencies;
@@ -110,6 +231,66 @@ public class Processor extends SettingsPreferenceFragment implements
         mCurFrequencyPref = (Preference) prefScreen.findPreference(FREQ_CUR_PREF);
         mMinFrequencyPref = (ListPreference) prefScreen.findPreference(FREQ_MIN_PREF);
         mMaxFrequencyPref = (ListPreference) prefScreen.findPreference(FREQ_MAX_PREF);
+        mSOBPref = (CheckBoxPreference) prefScreen.findPreference(SOB_PREF);
+
+        // Smartass preferences
+        mSmartassAwakeIdealFreqPref = (ListPreference) prefScreen.findPreference(SMARTASS_AWAKE_IDEAL_FREQ_PREF);
+        mSmartassSleepIdealFreqPref = (ListPreference) prefScreen.findPreference(SMARTASS_SLEEP_IDEAL_FREQ_PREF);
+        mSmartassSleepWakeupFreqPref = (ListPreference) prefScreen.findPreference(SMARTASS_SLEEP_WAKEUP_FREQ_PREF);
+        mSmartassMaxCpuLoadPref = (EditTextPreference) prefScreen.findPreference(SMARTASS_MAX_CPU_LOAD_PREF);
+        mSmartassMinCpuLoadPref = (EditTextPreference) prefScreen.findPreference(SMARTASS_MIN_CPU_LOAD_PREF);
+        mSmartassRampUpStepPref = (EditTextPreference) prefScreen.findPreference(SMARTASS_RAMP_UP_STEP_PREF);
+        mSmartassRampDownStepPref = (EditTextPreference) prefScreen.findPreference(SMARTASS_RAMP_DOWN_STEP_PREF);
+        mSmartassUpRateUsPref = (EditTextPreference) prefScreen.findPreference(SMARTASS_UP_RATE_US_PREF);
+        mSmartassDownRateUsPref = (EditTextPreference) prefScreen.findPreference(SMARTASS_DOWN_RATE_PREF);
+        mSmartassBoostEnabledPref = (CheckBoxPreference) prefScreen.findPreference(SMARTASS_BOOST_ENABLED_PREF);
+        mSmartassBoostPulsePref = (Preference) prefScreen.findPreference(SMARTASS_BOOST_PULSE_PREF);
+
+        // Voltage
+        if (Utils.fileExists(VDD_LEVELS_FILE)) {
+            // Build voltage list
+            String[] availableVoltages = new String[(VDD_MAX - VDD_MIN) / VDD_STEP + 1];
+            String[] voltages = new String[(VDD_MAX - VDD_MIN) / VDD_STEP + 1];
+            for (int mv = VDD_MIN; mv <= VDD_MAX; mv += VDD_STEP) {
+                availableVoltages[(mv - VDD_MIN) / VDD_STEP] = Integer.toString(mv);
+                voltages[(mv - VDD_MIN) / VDD_STEP] = String.format("%s mV", mv);
+                if (mv >= VDD_WARN)
+                    voltages[(mv - VDD_MIN) / VDD_STEP] += " " + getString(R.string.voltage_warning);
+            }
+
+            PreferenceCategory catVoltage = (PreferenceCategory) prefScreen.findPreference(VDD_LEVELS_CAT);
+
+            // Get current voltages
+            BufferedReader vddReader;
+            try {
+                vddReader = new BufferedReader(new FileReader(VDD_LEVELS_FILE), 512);
+                try {
+                    String line = null;
+                    while ((line = vddReader.readLine()) != null) {
+                        String freq = line.split(":")[0].trim();
+                        String mv = line.split(":")[1].trim();
+
+                        ListPreference pv = new ListPreference(prefScreen.getContext());
+                        pv.setTitle(toMHz(freq));
+                        pv.setDialogTitle(toMHz(freq));
+                        pv.setKey(VDD_LEVELS_PREF + freq);
+                        pv.setEntryValues(availableVoltages);
+                        pv.setEntries(voltages);
+                        pv.setValue(mv);
+                        pv.setSummary(String.format("%s mV (default %s mV)", mv, mvDefault.get(freq)));
+                        pv.setOnPreferenceChangeListener(this);
+
+                        catVoltage.addPreference(pv);
+                    }
+                } finally {
+                    vddReader.close();
+                }
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+
+            prefScreen.addPreference(catVoltage);
+        }
 
         /* Governor
         Some systems might not use governors */
@@ -174,8 +355,187 @@ public class Processor extends SettingsPreferenceFragment implements
 
         } else {
             mCurFrequencyPref.setSummary(toMHz(temp));
+        }
+
+        setSmartassValues(null);
+
+        mCurCPUThread.start();
+    }
+
+    private void setSmartassValues(Preference preference) {
+        String[] availableFrequencies = new String[0];
+        String[] frequencies;
+        String availableFrequenciesLine;
+        String temp;
+
+        if (!Utils.fileExists(FREQ_LIST_FILE) || (availableFrequenciesLine = Utils.fileReadOneLine(FREQ_LIST_FILE)) == null) {
+            mSmartassAwakeIdealFreqPref.setEnabled(false);
+            mSmartassSleepIdealFreqPref.setEnabled(false);
+            mSmartassSleepWakeupFreqPref.setEnabled(false);
+
+        } else {
+            availableFrequencies = availableFrequenciesLine.split(" ");
+
+            frequencies = new String[availableFrequencies.length];
+            for (int i = 0; i < frequencies.length; i++) {
+                frequencies[i] = toMHz(availableFrequencies[i]);
+            }
+
+            // Awake ideal freq
+            if (preference == null || preference == mSmartassAwakeIdealFreqPref) {
+                String file = String.format(SMARTASS_AWAKE_IDEAL_FREQ_FILE, getSmartass());
+                if (!Utils.fileExists(file) || (temp = Utils.fileReadOneLine(file)) == null) {
+                    mSmartassAwakeIdealFreqPref.setEnabled(false);
+                    mSmartassAwakeIdealFreqPref.setSummary(String.format(mSmartassAwakeIdealFreqFormat, ""));
+                } else {
+                    mSmartassAwakeIdealFreqPref.setEnabled(true);
+                    mSmartassAwakeIdealFreqPref.setEntryValues(availableFrequencies);
+                    mSmartassAwakeIdealFreqPref.setEntries(frequencies);
+                    mSmartassAwakeIdealFreqPref.setValue(temp);
+                    mSmartassAwakeIdealFreqPref.setSummary(String.format(mSmartassAwakeIdealFreqFormat, toMHz(temp)));
+                    mSmartassAwakeIdealFreqPref.setOnPreferenceChangeListener(this);
+                }
+            }
+
+            // Sleep ideal freq
+            if (preference == null || preference == mSmartassSleepIdealFreqPref) {
+                String file = String.format(SMARTASS_SLEEP_IDEAL_FREQ_FILE, getSmartass());
+                if (!Utils.fileExists(file) || (temp = Utils.fileReadOneLine(file)) == null) {
+                    mSmartassSleepIdealFreqPref.setEnabled(false);
+                    mSmartassSleepIdealFreqPref.setSummary(String.format(mSmartassSleepIdealFreqFormat, ""));
+                } else {
+                    mSmartassSleepIdealFreqPref.setEnabled(true);
+                    mSmartassSleepIdealFreqPref.setEntryValues(availableFrequencies);
+                    mSmartassSleepIdealFreqPref.setEntries(frequencies);
+                    mSmartassSleepIdealFreqPref.setValue(temp);
+                    mSmartassSleepIdealFreqPref.setSummary(String.format(mSmartassSleepIdealFreqFormat, toMHz(temp)));
+                    mSmartassSleepIdealFreqPref.setOnPreferenceChangeListener(this);
+                }
+            }
+
+            // Sleep wakeup freq
+            if (preference == null || preference == mSmartassSleepWakeupFreqPref) {
+                String file = String.format(SMARTASS_SLEEP_WAKEUP_FREQ_FILE, getSmartass());
+                if (!Utils.fileExists(file) || (temp = Utils.fileReadOneLine(file)) == null) {
+                    mSmartassSleepWakeupFreqPref.setEnabled(false);
+                    mSmartassSleepWakeupFreqPref.setSummary(String.format(mSmartassSleepWakeupFreqFormat, ""));
+                } else {
+                    mSmartassSleepWakeupFreqPref.setEnabled(true);
+                    mSmartassSleepWakeupFreqPref.setEntryValues(availableFrequencies);
+                    mSmartassSleepWakeupFreqPref.setEntries(frequencies);
+                    mSmartassSleepWakeupFreqPref.setValue(temp);
+                    mSmartassSleepWakeupFreqPref.setSummary(String.format(mSmartassSleepWakeupFreqFormat, toMHz(temp)));
+                    mSmartassSleepWakeupFreqPref.setOnPreferenceChangeListener(this);
+                }
+            }
+        }
+
+        // Max CPU load
+        if (preference == null || preference == mSmartassMaxCpuLoadPref) {
+            String file = String.format(SMARTASS_MAX_CPU_LOAD_FILE, getSmartass());
+            if (!Utils.fileExists(file) || (temp = Utils.fileReadOneLine(file)) == null) {
+                mSmartassMaxCpuLoadPref.setEnabled(false);
+                mSmartassMaxCpuLoadPref.setSummary(String.format(mSmartassMaxCpuLoadFormat, ""));
+            } else {
+                mSmartassMaxCpuLoadPref.setEnabled(true);
+                mSmartassMaxCpuLoadPref.setText(temp);
+                mSmartassMaxCpuLoadPref.setSummary(String.format(mSmartassMaxCpuLoadFormat, String.format("%s %%", temp)));
+                mSmartassMaxCpuLoadPref.setOnPreferenceChangeListener(this);
+            }
+        }
+
+        // Min CPU load
+        if (preference == null || preference == mSmartassMinCpuLoadPref) {
+            String file = String.format(SMARTASS_MIN_CPU_LOAD_FILE, getSmartass());
+            if (!Utils.fileExists(file) || (temp = Utils.fileReadOneLine(file)) == null) {
+                mSmartassMinCpuLoadPref.setEnabled(false);
+                mSmartassMinCpuLoadPref.setSummary(String.format(mSmartassMinCpuLoadFormat, ""));
+            } else {
+                mSmartassMinCpuLoadPref.setEnabled(true);
+                mSmartassMinCpuLoadPref.setText(temp);
+                mSmartassMinCpuLoadPref.setSummary(String.format(mSmartassMinCpuLoadFormat, String.format("%s %%", temp)));
+                mSmartassMinCpuLoadPref.setOnPreferenceChangeListener(this);
+            }
+        }
 
-            mCurCPUThread.start();
+        // Ramp up step
+        if (preference == null || preference == mSmartassRampUpStepPref) {
+            String file = String.format(SMARTASS_RAMP_UP_STEP_FILE, getSmartass());
+            if (!Utils.fileExists(file) || (temp = Utils.fileReadOneLine(file)) == null) {
+                mSmartassRampUpStepPref.setEnabled(false);
+                mSmartassRampUpStepPref.setSummary(String.format(mSmartassRampUpStepFormat, ""));
+            } else {
+                mSmartassRampUpStepPref.setEnabled(true);
+                mSmartassRampUpStepPref.setText(div1000(temp));
+                mSmartassRampUpStepPref.setSummary(String.format(mSmartassRampUpStepFormat, toMHz(temp)));
+                mSmartassRampUpStepPref.setOnPreferenceChangeListener(this);
+            }
+        }
+
+        // Ramp down step
+        if (preference == null || preference == mSmartassRampDownStepPref) {
+            String file = String.format(SMARTASS_RAMP_DOWN_STEP_FILE, getSmartass());
+            if (!Utils.fileExists(file) || (temp = Utils.fileReadOneLine(file)) == null) {
+                mSmartassRampDownStepPref.setEnabled(false);
+                mSmartassRampDownStepPref.setSummary(String.format(mSmartassRampDownStepFormat, ""));
+            } else {
+                mSmartassRampDownStepPref.setEnabled(true);
+                mSmartassRampDownStepPref.setText(div1000(temp));
+                mSmartassRampDownStepPref.setSummary(String.format(mSmartassRampDownStepFormat, toMHz(temp)));
+                mSmartassRampDownStepPref.setOnPreferenceChangeListener(this);
+            }
+        }
+
+        // Up rate use
+        if (preference == null || preference == mSmartassUpRateUsPref) {
+            String file = String.format(SMARTASS_UP_RATE_US_FILE, getSmartass());
+            if (!Utils.fileExists(file) || (temp = Utils.fileReadOneLine(file)) == null) {
+                mSmartassUpRateUsPref.setEnabled(false);
+                mSmartassUpRateUsPref.setSummary(String.format(mSmartassUpRateUsFormat, ""));
+            } else {
+                mSmartassUpRateUsPref.setEnabled(true);
+                mSmartassUpRateUsPref.setText(div1000(temp));
+                mSmartassUpRateUsPref.setSummary(String.format(mSmartassUpRateUsFormat, toMs(temp)));
+                mSmartassUpRateUsPref.setOnPreferenceChangeListener(this);
+            }
+        }
+
+        // Down rate use
+        if (preference == null || preference == mSmartassDownRateUsPref) {
+            String file = String.format(SMARTASS_DOWN_RATE_US_FILE, getSmartass());
+            if (!Utils.fileExists(file) || (temp = Utils.fileReadOneLine(file)) == null) {
+                mSmartassDownRateUsPref.setEnabled(false);
+                mSmartassDownRateUsPref.setSummary(String.format(mSmartassDownRateUsFormat, ""));
+            } else {
+                mSmartassDownRateUsPref.setEnabled(true);
+                mSmartassDownRateUsPref.setText(div1000(temp));
+                mSmartassDownRateUsPref.setSummary(String.format(mSmartassDownRateUsFormat, toMs(temp)));
+                mSmartassDownRateUsPref.setOnPreferenceChangeListener(this);
+            }
+        }
+
+        // Boost enabled
+        if (preference == null || preference == mSmartassBoostEnabledPref) {
+            String file = String.format(SMARTASS_BOOST_ENABLED_FILE, getSmartass());
+            if (!Utils.fileExists(file) || (temp = Utils.fileReadOneLine(file)) == null) {
+                mSmartassBoostEnabledPref.setEnabled(false);
+            } else {
+                mSmartassBoostEnabledPref.setEnabled(true);
+                mSmartassBoostEnabledPref.setChecked(!temp.startsWith("0"));
+                mSmartassBoostEnabledPref.setOnPreferenceChangeListener(this);
+            }
+        }
+
+        // Current boost pulse
+        if (preference == null || preference == mSmartassBoostPulsePref) {
+            String file = String.format(SMARTASS_BOOST_PULSE_FILE, getSmartass());
+            if (!Utils.fileExists(file) || (temp = Utils.fileReadOneLine(file)) == null) {
+                mSmartassBoostPulsePref.setEnabled(false);
+                mSmartassBoostPulsePref.setSummary(String.format(mSmartassBoostPulseFormat, ""));
+            } else {
+                mSmartassBoostPulsePref.setEnabled(true);
+                mSmartassBoostPulsePref.setSummary(String.format(mSmartassBoostPulseFormat, toMs(temp)));
+            }
         }
     }
 
@@ -196,8 +556,37 @@ public class Processor extends SettingsPreferenceFragment implements
         }
 
         if (Utils.fileExists(GOV_FILE) && (temp = Utils.fileReadOneLine(GOV_FILE)) != null) {
+            mGovernorPref.setValue(temp);
             mGovernorPref.setSummary(String.format(mGovernorFormat, temp));
         }
+
+        setSmartassValues(null);
+
+        // Voltage
+        if (Utils.fileExists(VDD_LEVELS_FILE)) {
+            PreferenceScreen prefScreen = getPreferenceScreen();
+
+            // Get current voltages
+            BufferedReader vddReader;
+            try {
+                vddReader = new BufferedReader(new FileReader(VDD_LEVELS_FILE), 512);
+                try {
+                    String line = null;
+                    while ((line = vddReader.readLine()) != null) {
+                        String freq = line.split(":")[0].trim();
+                        String mv = line.split(":")[1].trim();
+
+                        ListPreference pv = (ListPreference) prefScreen.findPreference(VDD_LEVELS_PREF + freq);
+                        pv.setValue(mv);
+                        pv.setSummary(String.format("%s mV (default %s mV)", mv, mvDefault.get(freq)));
+                    }
+                } finally {
+                    vddReader.close();
+                }
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
     }
 
     @Override
@@ -211,27 +600,78 @@ public class Processor extends SettingsPreferenceFragment implements
     }
 
     public boolean onPreferenceChange(Preference preference, Object newValue) {
-        String fname = "";
+        String fname = null;
+        String mv = null;
 
         if (newValue != null) {
+            // Safety first
+            if (preference != mSOBPref) {
+                mSOBPref.setChecked(false);
+                Toast toast = Toast.makeText(preference.getContext(),
+                    preference.getContext().getString(R.string.cpu_set_on_boot_disabled),
+                    Toast.LENGTH_SHORT);
+                toast.setGravity(Gravity.CENTER_HORIZONTAL | Gravity.CENTER_VERTICAL, 0, 0);
+                toast.show();
+            }
+
             if (preference == mGovernorPref) {
                 fname = GOV_FILE;
             } else if (preference == mMinFrequencyPref) {
                 fname = FREQ_MIN_FILE;
             } else if (preference == mMaxFrequencyPref) {
                 fname = FREQ_MAX_FILE;
+            } else if (preference == mSmartassAwakeIdealFreqPref) {
+                fname = String.format(SMARTASS_AWAKE_IDEAL_FREQ_FILE, getSmartass());
+            } else if (preference == mSmartassSleepIdealFreqPref) {
+                fname = String.format(SMARTASS_SLEEP_IDEAL_FREQ_FILE, getSmartass());
+            } else if (preference == mSmartassSleepWakeupFreqPref) {
+                fname = String.format(SMARTASS_SLEEP_WAKEUP_FREQ_FILE, getSmartass());
+            } else if (preference == mSmartassMaxCpuLoadPref) {
+                fname = String.format(SMARTASS_MAX_CPU_LOAD_FILE, getSmartass());
+            } else if (preference == mSmartassMinCpuLoadPref) {
+                fname = String.format(SMARTASS_MIN_CPU_LOAD_FILE, getSmartass());
+            } else if (preference == mSmartassRampUpStepPref) {
+                fname = String.format(SMARTASS_RAMP_UP_STEP_FILE, getSmartass());
+                newValue = by1000((String) newValue);
+            } else if (preference == mSmartassRampDownStepPref) {
+                fname = String.format(SMARTASS_RAMP_DOWN_STEP_FILE, getSmartass());
+                newValue = by1000((String) newValue);
+            } else if (preference == mSmartassUpRateUsPref) {
+                fname = String.format(SMARTASS_UP_RATE_US_FILE, getSmartass());
+                newValue = by1000((String) newValue);
+            } else if (preference == mSmartassDownRateUsPref) {
+                fname = String.format(SMARTASS_DOWN_RATE_US_FILE, getSmartass());
+                newValue = by1000((String) newValue);
+            } else if (preference == mSmartassBoostEnabledPref) {
+                fname = String.format(SMARTASS_BOOST_ENABLED_FILE, getSmartass());
+                newValue = (newValue.toString().equals("true") ? "1" : "0");
+            }
+            else if (preference.getKey().startsWith(VDD_LEVELS_PREF)) {
+                fname = VDD_LEVELS_FILE;
+                String freq = preference.getKey().substring(VDD_LEVELS_PREF.length());
+                mv = (String) newValue;
+                newValue = String.format("%s %s", freq, newValue);
+                Log.d(TAG, preference.getKey() + " freq=" + freq + " value=" + newValue);
             }
 
-            if (Utils.fileWriteOneLine(fname, (String) newValue)) {
+            if (fname != null && Utils.fileWriteOneLine(fname, (String) newValue)) {
                 if (preference == mGovernorPref) {
                     mGovernorPref.setSummary(String.format(mGovernorFormat, (String) newValue));
+                    setSmartassValues(null);
                 } else if (preference == mMinFrequencyPref) {
                     mMinFrequencyPref.setSummary(String.format(mMinFrequencyFormat,
                             toMHz((String) newValue)));
                 } else if (preference == mMaxFrequencyPref) {
                     mMaxFrequencyPref.setSummary(String.format(mMaxFrequencyFormat,
                             toMHz((String) newValue)));
+                } else if (preference.getKey().startsWith(VDD_LEVELS_PREF)) {
+                    String freq = preference.getKey().substring(VDD_LEVELS_PREF.length());
+                    preference.setSummary(String.format("%s mV (default %s mV)", mv, mvDefault.get(freq)));
                 }
+                else {
+                    setSmartassValues(preference);
+                }
+
                 return true;
             } else {
                 return false;
@@ -240,8 +680,42 @@ public class Processor extends SettingsPreferenceFragment implements
         return false;
     }
 
+    public static String getSmartass() {
+        if (Utils.fileExists(GOV_FILE)) {
+            String governor = Utils.fileReadOneLine(GOV_FILE);
+            if (governor.startsWith("smartassV2"))
+                return "smartass";
+            else if (governor.startsWith("SmartassH3"))
+                return "smartassH3";
+        }
+        return null;
+    }
+
     private String toMHz(String mhzString) {
         return new StringBuilder().append(Integer.valueOf(mhzString) / 1000).append(" MHz")
                 .toString();
     }
-}
\ No newline at end of file
+
+    private String toMs(String usString) {
+        return new StringBuilder().append(Integer.valueOf(usString) / 1000).append(" ms")
+                .toString();
+    }
+
+    private String div1000(String xString) {
+        try {
+            return Long.toString(Long.parseLong(xString) / 1000);
+        }
+        catch (NumberFormatException ex) {
+            return "";
+        }
+    }
+
+    public static String by1000(String xString) {
+        try {
+            return Long.toString(Long.parseLong(xString) * 1000);
+        }
+        catch (NumberFormatException ex) {
+            return "";
+        }
+    }
+}
